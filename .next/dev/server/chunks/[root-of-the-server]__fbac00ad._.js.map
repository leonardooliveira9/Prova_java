{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo/Downloads/Prova%20Java/lib/db/mysql-client.ts"],"sourcesContent":["// Utilidade para conectar ao MySQL e executar queries\nimport mysql from \"mysql2/promise\"\n\nlet connection: mysql.Connection | null = null\n\n/**\n * Parse uma connection string MySQL no formato: mysql://user:password@host:port/database\n */\nfunction parseConnectionString(connectionString: string): Record<string, string | number> {\n  const url = new URL(connectionString.replace(/^mysql:\\/\\//, \"mysql://\"))\n\n  return {\n    host: url.hostname || \"localhost\",\n    user: url.username || \"root\",\n    password: url.password || \"\",\n    database: url.pathname.slice(1) || \"neurobyte\",\n    port: url.port ? Number.parseInt(url.port) : 3306,\n  }\n}\n\n/**\n * Cria ou retorna uma conexão existente com o MySQL\n * Aceita connection string no formato: mysql://user:password@host:port/database\n * Ou variáveis de ambiente: MYSQL_HOST, MYSQL_USER, MYSQL_PASSWORD, MYSQL_DATABASE, MYSQL_PORT\n */\nexport async function getConnection(connectionString?: string): Promise<mysql.Connection> {\n  if (connection) {\n    return connection\n  }\n\n  try {\n    let config: Record<string, string | number>\n\n    if (connectionString) {\n      config = parseConnectionString(connectionString)\n    } else {\n      config = {\n        host: process.env.MYSQL_HOST || \"localhost\",\n        user: process.env.MYSQL_USER || \"root\",\n        password: process.env.MYSQL_PASSWORD || \"\",\n        database: process.env.MYSQL_DATABASE || \"neurobyte\",\n        port: Number.parseInt(process.env.MYSQL_PORT || \"3306\"),\n      }\n    }\n\n    connection = await mysql.createConnection({\n      host: config.host as string,\n      user: config.user as string,\n      password: config.password as string,\n      database: config.database as string,\n      port: config.port as number,\n      waitForConnections: true,\n      connectionLimit: 5,\n      queueLimit: 0,\n    })\n\n    console.log(\"[v0] MySQL connection established successfully\")\n    return connection\n  } catch (error) {\n    console.error(\"[v0] Failed to connect to MySQL:\", error)\n    throw new Error(`Database connection failed: ${error instanceof Error ? error.message : \"Unknown error\"}`)\n  }\n}\n\n/**\n * Fecha a conexão com o MySQL\n */\nexport async function closeConnection(): Promise<void> {\n  if (connection) {\n    await connection.end()\n    connection = null\n    console.log(\"[v0] MySQL connection closed\")\n  }\n}\n\n/**\n * Executa uma query genérica no MySQL\n */\nexport async function executeQuery(sql: string, values: any[] = []): Promise<any> {\n  try {\n    const conn = await getConnection()\n    const [results] = await conn.execute(sql, values)\n    return results\n  } catch (error) {\n    console.error(\"[v0] Query execution error:\", error)\n    throw new Error(`Database query failed: ${error instanceof Error ? error.message : \"Unknown error\"}`)\n  }\n}\n"],"names":[],"mappings":"AAAA,sDAAsD;;;;;;;;;AACtD;;AAEA,IAAI,aAAsC;AAE1C;;CAEC,GACD,SAAS,sBAAsB,gBAAwB;IACrD,MAAM,MAAM,IAAI,IAAI,iBAAiB,OAAO,CAAC,eAAe;IAE5D,OAAO;QACL,MAAM,IAAI,QAAQ,IAAI;QACtB,MAAM,IAAI,QAAQ,IAAI;QACtB,UAAU,IAAI,QAAQ,IAAI;QAC1B,UAAU,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM;QACnC,MAAM,IAAI,IAAI,GAAG,OAAO,QAAQ,CAAC,IAAI,IAAI,IAAI;IAC/C;AACF;AAOO,eAAe,cAAc,gBAAyB;IAC3D,IAAI,YAAY;QACd,OAAO;IACT;IAEA,IAAI;QACF,IAAI;QAEJ,IAAI,kBAAkB;YACpB,SAAS,sBAAsB;QACjC,OAAO;YACL,SAAS;gBACP,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;gBAChC,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;gBAChC,UAAU,QAAQ,GAAG,CAAC,cAAc,IAAI;gBACxC,UAAU,QAAQ,GAAG,CAAC,cAAc,IAAI;gBACxC,MAAM,OAAO,QAAQ,CAAC,QAAQ,GAAG,CAAC,UAAU,IAAI;YAClD;QACF;QAEA,aAAa,MAAM,0KAAK,CAAC,gBAAgB,CAAC;YACxC,MAAM,OAAO,IAAI;YACjB,MAAM,OAAO,IAAI;YACjB,UAAU,OAAO,QAAQ;YACzB,UAAU,OAAO,QAAQ;YACzB,MAAM,OAAO,IAAI;YACjB,oBAAoB;YACpB,iBAAiB;YACjB,YAAY;QACd;QAEA,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oCAAoC;QAClD,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,iBAAiB;IAC3G;AACF;AAKO,eAAe;IACpB,IAAI,YAAY;QACd,MAAM,WAAW,GAAG;QACpB,aAAa;QACb,QAAQ,GAAG,CAAC;IACd;AACF;AAKO,eAAe,aAAa,GAAW,EAAE,SAAgB,EAAE;IAChE,IAAI;QACF,MAAM,OAAO,MAAM;QACnB,MAAM,CAAC,QAAQ,GAAG,MAAM,KAAK,OAAO,CAAC,KAAK;QAC1C,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,iBAAiB;IACtG;AACF"}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo/Downloads/Prova%20Java/lib/db/product-repository.ts"],"sourcesContent":["// Repository para operações de produtos no MySQL\nimport { executeQuery } from \"./mysql-client\"\n\n/**\n * Interface para produto no banco de dados\n */\nexport interface MySQLProduct {\n  id: number\n  name: string\n  description: string\n  price: number\n  category: string\n  stock: number\n  image_url: string\n  created_at: Date\n  updated_at: Date\n}\n\n/**\n * Busca todos os produtos do MySQL\n */\nexport async function getAllProductsFromDB(): Promise<MySQLProduct[]> {\n  const sql = `\n    SELECT id, name, description, price, category, stock, image_url, created_at, updated_at\n    FROM products\n    ORDER BY created_at DESC\n  `\n\n  return await executeQuery(sql)\n}\n\n/**\n * Busca um produto específico pelo ID\n */\nexport async function getProductByIdFromDB(id: number): Promise<MySQLProduct | null> {\n  const sql = `\n    SELECT id, name, description, price, category, stock, image_url, created_at, updated_at\n    FROM products\n    WHERE id = ?\n    LIMIT 1\n  `\n\n  const results = await executeQuery(sql, [id])\n  return results.length > 0 ? results[0] : null\n}\n\n/**\n * Busca produtos por categoria\n */\nexport async function getProductsByCategoryFromDB(category: string): Promise<MySQLProduct[]> {\n  const sql = `\n    SELECT id, name, description, price, category, stock, image_url, created_at, updated_at\n    FROM products\n    WHERE category = ?\n    ORDER BY name ASC\n  `\n\n  return await executeQuery(sql, [category])\n}\n\n/**\n * Cria um novo produto\n */\nexport async function createProductInDB(\n  product: Omit<MySQLProduct, \"id\" | \"created_at\" | \"updated_at\">,\n): Promise<number> {\n  const sql = `\n    INSERT INTO products (name, description, price, category, stock, image_url, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())\n  `\n\n  const results = await executeQuery(sql, [\n    product.name,\n    product.description,\n    product.price,\n    product.category,\n    product.stock,\n    product.image_url,\n  ])\n\n  return results.insertId\n}\n\n/**\n * Atualiza um produto existente\n */\nexport async function updateProductInDB(id: number, product: Partial<MySQLProduct>): Promise<boolean> {\n  const fields: string[] = []\n  const values: any[] = []\n\n  if (product.name) {\n    fields.push(\"name = ?\")\n    values.push(product.name)\n  }\n  if (product.description) {\n    fields.push(\"description = ?\")\n    values.push(product.description)\n  }\n  if (product.price !== undefined) {\n    fields.push(\"price = ?\")\n    values.push(product.price)\n  }\n  if (product.category) {\n    fields.push(\"category = ?\")\n    values.push(product.category)\n  }\n  if (product.stock !== undefined) {\n    fields.push(\"stock = ?\")\n    values.push(product.stock)\n  }\n  if (product.image_url) {\n    fields.push(\"image_url = ?\")\n    values.push(product.image_url)\n  }\n\n  fields.push(\"updated_at = NOW()\")\n  values.push(id)\n\n  if (fields.length === 1) return false // Nenhum campo para atualizar\n\n  const sql = `UPDATE products SET ${fields.join(\", \")} WHERE id = ?`\n\n  const results = await executeQuery(sql, values)\n  return results.affectedRows > 0\n}\n\n/**\n * Deleta um produto\n */\nexport async function deleteProductFromDB(id: number): Promise<boolean> {\n  const sql = \"DELETE FROM products WHERE id = ?\"\n  const results = await executeQuery(sql, [id])\n  return results.affectedRows > 0\n}\n\n/**\n * Retorna os IDs únicos de todas as categorias\n */\nexport async function getCategoriesFromDB(): Promise<string[]> {\n  const sql = \"SELECT DISTINCT category FROM products ORDER BY category ASC\"\n  const results = await executeQuery(sql)\n  return results.map((row: any) => row.category)\n}\n"],"names":[],"mappings":"AAAA,iDAAiD;;;;;;;;;;;;;;;;;AACjD;;AAoBO,eAAe;IACpB,MAAM,MAAM,CAAC;;;;EAIb,CAAC;IAED,OAAO,MAAM,IAAA,0KAAY,EAAC;AAC5B;AAKO,eAAe,qBAAqB,EAAU;IACnD,MAAM,MAAM,CAAC;;;;;EAKb,CAAC;IAED,MAAM,UAAU,MAAM,IAAA,0KAAY,EAAC,KAAK;QAAC;KAAG;IAC5C,OAAO,QAAQ,MAAM,GAAG,IAAI,OAAO,CAAC,EAAE,GAAG;AAC3C;AAKO,eAAe,4BAA4B,QAAgB;IAChE,MAAM,MAAM,CAAC;;;;;EAKb,CAAC;IAED,OAAO,MAAM,IAAA,0KAAY,EAAC,KAAK;QAAC;KAAS;AAC3C;AAKO,eAAe,kBACpB,OAA+D;IAE/D,MAAM,MAAM,CAAC;;;EAGb,CAAC;IAED,MAAM,UAAU,MAAM,IAAA,0KAAY,EAAC,KAAK;QACtC,QAAQ,IAAI;QACZ,QAAQ,WAAW;QACnB,QAAQ,KAAK;QACb,QAAQ,QAAQ;QAChB,QAAQ,KAAK;QACb,QAAQ,SAAS;KAClB;IAED,OAAO,QAAQ,QAAQ;AACzB;AAKO,eAAe,kBAAkB,EAAU,EAAE,OAA8B;IAChF,MAAM,SAAmB,EAAE;IAC3B,MAAM,SAAgB,EAAE;IAExB,IAAI,QAAQ,IAAI,EAAE;QAChB,OAAO,IAAI,CAAC;QACZ,OAAO,IAAI,CAAC,QAAQ,IAAI;IAC1B;IACA,IAAI,QAAQ,WAAW,EAAE;QACvB,OAAO,IAAI,CAAC;QACZ,OAAO,IAAI,CAAC,QAAQ,WAAW;IACjC;IACA,IAAI,QAAQ,KAAK,KAAK,WAAW;QAC/B,OAAO,IAAI,CAAC;QACZ,OAAO,IAAI,CAAC,QAAQ,KAAK;IAC3B;IACA,IAAI,QAAQ,QAAQ,EAAE;QACpB,OAAO,IAAI,CAAC;QACZ,OAAO,IAAI,CAAC,QAAQ,QAAQ;IAC9B;IACA,IAAI,QAAQ,KAAK,KAAK,WAAW;QAC/B,OAAO,IAAI,CAAC;QACZ,OAAO,IAAI,CAAC,QAAQ,KAAK;IAC3B;IACA,IAAI,QAAQ,SAAS,EAAE;QACrB,OAAO,IAAI,CAAC;QACZ,OAAO,IAAI,CAAC,QAAQ,SAAS;IAC/B;IAEA,OAAO,IAAI,CAAC;IACZ,OAAO,IAAI,CAAC;IAEZ,IAAI,OAAO,MAAM,KAAK,GAAG,OAAO,MAAM,8BAA8B;;IAEpE,MAAM,MAAM,CAAC,oBAAoB,EAAE,OAAO,IAAI,CAAC,MAAM,aAAa,CAAC;IAEnE,MAAM,UAAU,MAAM,IAAA,0KAAY,EAAC,KAAK;IACxC,OAAO,QAAQ,YAAY,GAAG;AAChC;AAKO,eAAe,oBAAoB,EAAU;IAClD,MAAM,MAAM;IACZ,MAAM,UAAU,MAAM,IAAA,0KAAY,EAAC,KAAK;QAAC;KAAG;IAC5C,OAAO,QAAQ,YAAY,GAAG;AAChC;AAKO,eAAe;IACpB,MAAM,MAAM;IACZ,MAAM,UAAU,MAAM,IAAA,0KAAY,EAAC;IACnC,OAAO,QAAQ,GAAG,CAAC,CAAC,MAAa,IAAI,QAAQ;AAC/C"}},
    {"offset": {"line": 313, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Leonardo/Downloads/Prova%20Java/app/api/db/products/route.ts"],"sourcesContent":["// API para buscar produtos do MySQL\nimport { type NextRequest, NextResponse } from \"next/server\"\nimport { getAllProductsFromDB } from \"@/lib/db/product-repository\"\n\nexport async function GET(request: NextRequest) {\n  try {\n    const products = await getAllProductsFromDB()\n\n    return NextResponse.json({\n      success: true,\n      products,\n      count: products.length,\n    })\n  } catch (error) {\n    console.error(\"[v0] Error fetching products:\", error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : \"Erro ao buscar produtos\" },\n      { status: 500 },\n    )\n  }\n}\n"],"names":[],"mappings":"AAAA,oCAAoC;;;;;AACpC;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,wLAAoB;QAE3C,OAAO,4KAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,OAAO,SAAS,MAAM;QACxB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,4KAAY,CAAC,IAAI,CACtB;YAAE,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAA0B,GAC5E;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}